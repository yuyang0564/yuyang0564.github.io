{"posts":[{"title":"CROS","content":"跨域 Ajax 通信的主要限制就是跨域的安全策略,它要求发起请求的域名必须与接收请求的域名必须是同源的，属于浏览器保护资源的一种行为 同源策略 同源策略是指: 协议、域名、端口 必须严格一致 &quot;http://www.baidu.com&quot; &quot;https://www.baidu.com&quot; // 协议不同导致跨域 &quot;http://www.baidu.com:8080&quot; &quot;https://www.baidu.com&quot; // 端口不同导致跨域 &quot;https://www.baidu.com&quot; &quot;https://www.baidu.cn&quot; // 域名不同导致跨域 CROS 浏览器通过“跨域资源共享”解决跨域问题 , 它的基本思路就是使用自定义的HTTP头部允许浏览器与服务器之间相互了解 简单请求: GET 、 POST 当没有自定义请求头,请求类型为text/plain时，浏览器会发送一个额外的请求头 Origin, 它包含了发送请求页面的[协议,域名,端口] , 用来让服务器确定是否为其提供响应 如果服务器为其提供响应,则会再响应头 Access-Control-Allow-Origin 包含相同的源，或者是公共资源时可以为 * 复杂请求 除了上述简单请求之外，其余的都为复杂请求。浏览器会先发送一个 OPTIONS请求也叫做预检请求,请求头中会包含: Origin 确认源 Access-Control-Request-Method 希望请求的方法 Access-Control-Request-Headers 希望使用的请求头,以逗号分隔 服务器需要返回: Access-Control-Allow-Origin： 确认源 Access-Control-Allow-Methods：允许的方法（逗号分隔的列表）。 Access-Control-Allow-Headers：服务器允许的头部（逗号分隔的列表）。 Access-Control-Max-Age：缓存预检请求的秒数，再缓存的时间内不会再发送 OPTIONS 请求 ","link":"https://yuyang0564.github.io/Q9Jq_SO1i/"},{"title":"8. 表单","content":"表单 form 元素对应javascript 中的 HTMLFormElement 类型，它除了继承 HTMLElement 中的默认属性外，还有一些自己的默认行为 action : 请求的URL length : 表单中控件的数量 elements : 表单中所有控件的 HTMLCollection method : 请求方法 name : 表单的名字 reset() : 重置表单 submit() : 提交表单 获取表单 通过 id 通过 document.forms 获取页面中的所有表单,它返回一个HTMLCollction,然后通过索引或name访问特定的表单 &lt;form action=&quot;get&quot; name=&quot;form1&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;script&gt; const hl = document.forms console.log(hl[0]) console.log(hl[&quot;form1&quot;]) &lt;/script&gt; 传统提交表单 在 form 中使用下列任一均可提交表单: &lt;input type=&quot;submit&quot; value=&quot;提交按钮&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交按钮&lt;/button&gt; &lt;input type=&quot;image&quot; src=&quot;submit.png&quot;&gt; 事件 submit事件 当点击提交按钮时会自动触发submit 事件 form.addEventListener(&quot;submit&quot;,(event)=&gt;{ }) 或者对表单进行验证失败时，阻止表单的提交 form.addEventListent(&quot;submit&quot;,(event)=&gt;{ ... event.preventDdefault() // 阻止表单的提交 }) 获取表单中的控件 表单对象有一个 elements 属性,它返回当前表单的所有控件集合,它们的顺序就是当前表单书写的顺序。可以通过索引来获取元素,或者通过表单的 name 属性 &lt;form action=&quot;get&quot; name=&quot;form1&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; id=&quot;user&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; let form = document.form[&quot;form1&quot;] // 方法一: 过表单获取控件 let nameInput = form.elements[&quot;user&quot;] // 方法二: 通过索引来获取 let nameInput = form.elements[0] 表单控件共有的属性 disabled : 控件是否禁用 form : 指向当前所在的表单 name : 当前控件的名字 readyOnly : 当前控件是否是只读的 tpye : 当前控件的类型 value : 提交到服务器的值 HTML5 新增表单验证 required 必填字段 &lt;input type=&quot;text&quot; name=&quot;user&quot; required&gt; pattern 对控件的值使用正则表达式验证 注意: 此验证严格按照从头至尾的规则 &lt;input type=&quot;text&quot; name=&quot;user&quot; pattern=&quot;\\d+&quot;&gt; 所有的表单元素上都有一个 checkValidity() 方法,用于验证设置了以上2种规则的表单元素。如果一个表单元素没有设置任何一种验证规则，则这个方法始终返回true form 元素上的 checkValidity() 方法会检查整个表单是否通过验证 File Api 文件系统 web浏览器访问文件的唯一方式是通过表单中的文件上传 &lt;input type=&quot;file&quot;/&gt; 上传后的文件会保存在 FileList 对象中, 它是一个伪数组，拥有length属性。可以通过 Array.from() 转为数组 通过索引可以获得上传的每一个文件的一些信息。每个文件对象都有一些只读属性: name: 文件在系统中的名字 size: 文件的大小 (Kb 为单位) type: 文件的MIME类型 通过 FileReader 读取文件 从本地上传的文件会暂存在内存中,可以通过 FileReader 从内存中异步读取出文件数据 readAsText(file,encoding) 从文件读取纯文本内容 readAsDataURL(file) 读取文件到URI readAsArrayBuffer(file) 读取文件到ArrayBuffer abort() 提前结束文件读取 读取文件的结果会保存在 FileReader实例 的 result 属性中 FileReader 提供了3个事件 progress 、 error 、 load , 它们分别表示读取进度,读取错误,读取完成 progress 事件每隔 50ms 会触发一次 , event 对象中的 total 和 loaded 分别表示 文件总大小和已上传文件大小 const rd = new FileReader() rd.addEventListener(&quot;progress&quot;,(e)=&gt;{ if(e.total === e.loaded) { // 文件上传完成 } }) error 事件会在读取文件发生错误时触发, 会保存在FileReader实例的 error 属性的 code 属性中,这个属性是一个错误码数值 1 未找到文件 2 安全错误 3 读取被中断 4 文件不可读 5 编码错误 rd.addEventListener(&quot;error&quot;,()=&gt;{ console.log(rd.error.code) }) load 事件会在文件读取成功时触发,可以通过 FileReader 实例的 result 属性获取读取结果 rd.addEventListener(&quot;load&quot;,()=&gt;{ ... rd.result }) Blob URL 它可以不用把文件内容读取到javascript,而直接引用File 或者 Blob 中的数据URL window.URL.createObjectURL(File | Blob) 该方法返回内存地址的 URL 字符串，可以被 DOM 直接引用 当某个 URL 不再使用时使用如下方法及时释放内存 window.URL.revokeObjecURL( string ) ","link":"https://yuyang0564.github.io/ArI6WIEAL/"},{"title":"3.2 innerText/outerText","content":"innerText 1. 读取 获取该元素所有后代元素的文本内容 &lt;ul&gt; &lt;li&gt; a &lt;div&gt; b &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; let ul = document.querySelect(&quot;ul&quot;) ul.innerText /* a b */ 2. 写入 设置的内容将替换该元素的所有后代 &lt;ul&gt; &lt;li&gt; a &lt;div&gt; b &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; let ul = document.querySelect(&quot;ul&quot;) ul.innerText = &quot;a&quot; /* &lt;ul&gt; a &lt;/ul&gt; */ 注意: 如果设置的内容中存在 HTML 的语法字符，则会被转义 (包括 “小于号、大于号、引号及和号”) &lt;div&gt; &lt;p&gt;子节点&lt;/p&gt; &lt;/div&gt; &lt;script&gt; ... div.innerText = &quot;Hello &amp; welcome, &lt;b&gt;\\&quot;reader\\&quot;!&lt;/b&gt;&quot;; // 会被转义为 /* &lt;div&gt; Hello &amp;amp; welcome, &amp;lt;b&amp;gt;&amp;quot;reader&amp;quot;!&amp;lt;/b&amp;gt; &lt;/div&gt; */ &lt;/script&gt; outerText 1. 读取 与 innerText 功能一致 2. 写入 写入时它会连同调用的元素节点一同替换 ","link":"https://yuyang0564.github.io/pnW_OFHNM/"},{"title":"3.1 innerHTML/outerHTML","content":"innerHTML 1. 读取 读取innerHTML时,返回该元素的所有后代节点的字符串形式 &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const ul = document.quertSelect(&quot;ul&quot;) console.log(ul.innerHTML) /* &lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt; */ &lt;/script&gt; 2. 写入 通过 innerHTML 写入时，将根据写入的字符串以新的DOM子数替换掉源子节点 &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const ul = document.quertSelect(&quot;ul&quot;) ul.innerHTML = &quot;&lt;li&gt;替换的节点&lt;/li&gt;&quot; /* &lt;ul&gt; &lt;li&gt;替换的节点&lt;/li&gt; &lt;/ul&gt; */ &lt;/script&gt; 如果写入的内容不含 HTML 标签则会生成一个文本节点 &lt;div&gt; &lt;p&gt;源节点&lt;/p&gt; &lt;/div&gt; &lt;script&gt; const div = document.quertSelect(&quot;div&quot;) div.innerHTML = &quot;替换&quot; /* &lt;div&gt;替换&lt;/div&gt; */ &lt;/script&gt; outerHTML 1. 读取 读取时会连同调用的元素及其子元素一起,以HTML字符串的方式返回 &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const ul = document.quertSelect(&quot;ul&quot;) console.log(ul.outerHTML) /* &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; */ &lt;/script&gt; 2. 写入 写入时，写入的内容将完全替换当前的元素 &lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt; &lt;script&gt; const div = document.quertSelect(&quot;div&quot;) div.outerHTML = &quot;&lt;h1&gt;替换&lt;/h1&gt;&quot; &lt;/script&gt; 以上面的代码为例,outerHTML相当于新建一个&lt;h1&gt;元素，然后替换掉 &lt;div&gt; const p = document.createElement(&quot;h1&quot;) h1.appendChild(document.createTextNode(&quot;替换&quot;)) div.parentNode.replaceChild(p,div) ","link":"https://yuyang0564.github.io/-ok0OSKyp/"},{"title":"async/await 异步函数","content":"基础 async/await 是ES8新增的一组规范, 它可以让我们以同步方式书写的代码,以异步的方式执行 1. async 关键字 async 用来声明一个异步函数,它可以使用在 函数声明,函数表达式,箭头函数 async function fn() {} let fn = async function() {} class NewClass { async fn() {} } let fn = async () =&gt; {} 提示: 声明为 async 的函数还是会同步执行的。 不过在 return 时, 返回值会经过 Promise.resolve 包装 console.log(1); fn().then(console.log) async function fn() { console.log(2); return 4 } console.log(3); // 1 2 3 4 2. await 关键字 await 只能使用在 async 标识的函数中, 单独使用会报错。 它会暂停异步函数的执行， 让出执行线程，优先执行异步函数之外的同步代码,之后再回到第一个 await 处，恢复执行 async function foo() { console.log(1); let p = new Promise((resolve,reject)=&gt;{setTimeout(resolve,1000,3)}) console.log(2); console.log(await p); console.log(4); } foo() console.log(5); // 1 2 5 3 4 当 await 遇到抛出错误或状态变为rejected，会停止执行之后的代码 async function foo() { console.log(1); let p = new Promise((resolve,reject)=&gt;{setTimeout(reject,1000,3)}) console.log(2); console.log(await p); console.log(4); } foo() console.log(5); // 1 2 5 ","link":"https://yuyang0564.github.io/wqT1wMNt9/"},{"title":"Promise","content":"Promise 从ES6开始，新增了一个Promise的引用类型,它完善了promise/A+的规范,现已成为异步编程的主要技术手段,其最主要的功能是可以知道一个异步代码是否执行完毕，并解决了传统异步编程中回调地狱的问题 基础 通过 new Promise 初始化，构造函数接收一个函数参数作为执行器，如果参数是非函数则会报出 SyntaxError 语法错误 一、状态/执行函数 Promise 类型的实例是一个有状态的对象，它有3种状态 pending //待定 fulfilled //解决 rejected //拒绝 待定(pending) 为默认初始状态,在待定状态下可以让 promise实例 变更为 (fulfilled) 或者 (rejected)，状态只能改变一次 , 一旦 promise 的状态发生改变, 状态就固定了并且不可逆 const p1 = new Promise((resolve,reject)=&gt;{ resolve() reject() // 静默失败,状态已经 fulfilled }) 传入 Promise构造函数的 执行函数 会接收 2 个 函数参数, resolve() 和 reject()，调用 resolve 会把 pending 状态变更为 解决(fulfilled), 调用 reject 会把 pending 状态变更为拒绝(rejected) 并抛出一个异步错误 注意： reject 抛出的异步错误,无法用 try/catch 捕获，因为他们不在同步代码的线程里 const p1 = new Promise((resolve,reject)=&gt; resolve()) // fulfilled const p2 = new Promise((resolve,reject)=&gt; reject()) // rejected 提示： 传入 Promise 构造函数的 执行函数 是同步执行的,但是状态变更函数是异步执行的 const p = new Promise((resolve,reject)=&gt;{ console.log(1); setTimeout(console.log,0,2) resolve(3) console.log(4) }) console.log(5) p.then(res=&gt;{ console.log(res); }) setTimeout(console.log,0,6) // 输出 1 4 5 3 2 6 注意以下特殊情况: 如果没有向状态变更函数传递参数，则状态返回的值为 undefined 如果没有调用状态变更函数，则返回的任意值都会被忽略, 状态依旧是 pending, // 1 const p = new Promise((resolve,reject)=&gt;{ resolve() }) // 2 const p = new Promise((resolve,reject)=&gt;{ return true }) 二、 静态函数 Promise实例的状态并非一定需要从 pending 状态开始，然后再通过执行函数转换为其他状态。Promise 提供了2个静态函数resolve()和reject()可以直接实例化一个解决(fulfilled)和拒绝(rejected)的对象 const p1 = Promise.resolve() // fulfilled const p2 = Promise.reject() // rejected resolve 静态方法接收一个参数(多余的会被忽略),可以把传入的任意值包装成一个新的(fulfilled)Promise对象返回,如果传入的值本身就是一个promise类型,则会原样返回 const p1 = Promise.resolve(1) const p2 = Promise.resolve(&quot;1&quot;) const p3 = Promise.resolve(true) const p4 = Promise.resolve(()=&gt;{}) const p5 = Promise.resolve(null) const p6 = Promise.resolve(Promise.resolve(1)) reject 静态方法与resolve在使用上一致,可以把传入的任意值包装成(rejected)Promise对象返回并抛出一个异步错误 三、 Promise 实例的方法 第一个实例方法 then Promise.prototype.then() Promise 原型对象上有一个 then 方法, 它接收2个可选的函数参数,第一个是在状态变更为 (fulfilled)时的处理函数,第二个是在状态变更为(rejected)时的处理函数。这两个处理函数是互斥的，也就是说始终只会有一个函数执行 const p1 = Promise.resolve(1) p1.then( function(res) { // fulfilled 时执行 }, function(rej) { // rejected 时执行 } ) 注意： then 函数接收的是非函数类型时会被忽略 p1.then(&quot;good&quot;) // 错误处理方式 then 方法也会返回一个新的 Promise对象 const p1 = new Promise((resolve,reject)=&gt;{ resolve(&quot;good&quot;) }) const p2 = p1.then() 如果调用then时没有传入处理函数，则源状态会原样向后传 const p1 = new Promise((resolve,reject)=&gt;{ reject(&quot;err&quot;) }) const p2 = p1.then() // &quot;rejected&quot;, &quot;err&quot; const p3 = p2.then() // &quot;rejected&quot;, &quot;err&quot; 第二个实例方法catch Promise.prototype.catch() 它只接受一个参数: reject 处理方法,这个方法就是一个语法糖，与Promise.prototype.then(null,reject) 等价 , 其行为也与 then 一致 // 等同于 Promise.prototype.then(null,reject) 注意： then 和 catch 均会等待当前线程中同步方法执行完毕后再执行 let syncFunc, p = new Promise(resolve =&gt; { syncFunc = function () { console.log(1) resolve() console.log(2) } }) p.then(()=&gt;{ console.log(3) }) syncFunc() console.log(4) // 1 2 4 3 四、 拒绝(rejected)Promise的处理 无论是使用 Promise.reject( ) 或在Promise 执行函数中使用 throw 都会生成一个 rejected Promise对象 const p1 = new Promise((resolve,reject)=&gt;{reject(&quot;err&quot;)}) const p2 = new Promise((resolve,reject)=&gt;{throw &quot;err&quot;}) const p3 = Promise.reject(&quot;err&quot;) const p4 = Promise.reject(Error(&quot;err&quot;)) 如上文所说&quot;异步程序的异常错误不能使用 try/catch 捕获&quot;, 转而应该使用 Promise.prototype.catch() 或者 Promise.prototype.then(null,reject) 五、 其余静态方法 1. 将一组 Promise 合并到一起串行执行 Promise.all() 接收一个数组参数,数组中的每一项都会经过 Promise.resolve 转换为 Promise对象 const p = Promise.all([ 1, '1', true, function(){}, null, Promise.resolve() ]) 如果所有的Promise状态都变更为了 fulfilled, 则 Promise.all 的状态才能变为fulfilled , 返回的值就是所有 Promise 执行后的返回值组成的数组 function fn() { return Promise.resolve(2) } Promise.all([ Promise.resolve(1), fn(), Promise.resolve(3) ]).then(res=&gt;{ console.log(res); }) // [1,2,3] 只要有一个 Promise 的状态变为了 rejected, 则 Promise.all 的状态就会变为 rejected , 返回第一个状态变更为rejected的返回的值 function fn() { return Promise.reject(2) } Promise.all([ Promise.resolve(1), fn(), Promise.resolve(3), Promise.reject(4) ]).catch(err=&gt;{ console.log(err); }) // 2 导致 Promise.all 状态变更为 rejected时，并不会影响到其他 Promise 的执行 Promise.all([ Promise.resolve(console.log(1)), Promise.resolve(console.log(2)), Promise.reject(3), Promise.resolve(console.log(4)) ]).catch(err=&gt;{ console.log(err); }) // 1 2 4 3 ","link":"https://yuyang0564.github.io/DHz3NA5h8/"},{"title":"flex 布局","content":"基本概念 flexbox 是一维布局模型 , 它通过 2 根轴线决定成员的排列方式 。 被设置为 flexbox 的元素被称为容器 , 容器的子元素被称为flex成员 主轴、交叉轴 flexbox 的默认主轴为横向排列，即从左至右 而 默认交叉轴 则为从上至下 通过 flex-direction 改变主轴的方向 row 默认主轴，横向从左至右 row-reverse 横向,反方向 column 纵向, 从上至下 column-reverse 纵向,从下至上 创建容器 通过为一个元素设置 display 属性为 flex 或 inline-flex，即将该元素创建为容器。容器的直接子元素都会成为 flex成员。 display: flex; display: inline-flex; flex成员默认具有如下特征: 按照主轴的方向依次排列 成员不会在主轴方向拉伸和换行，但是在容器剩余空间不足时，会缩小。当有太多成员超出容器大小时，会溢出容器 横向排列时，当成员没有设置高度时,会在交叉轴上拉伸，填充交叉轴。(纵向排列时为宽度) 横向排列时，当某个成员的高度超出容器的高度，则会溢出(纵向排列时为宽度) 多行 flex容器 通过为容器设置 flex-wrap 来决定容器是否启用换行。即成员不会等分容器的宽度，而是根据自身的宽度排列，超出容器时换行排列 flex-wrap: wrap; // 换行 flex-wrap: nowrap; // 不换行 可以将 flex-direction 和 flex-wrap 合并成简写属性 flex-flow, 第一个值为 flex-direction , 第二个值为 flex-wrap flex-flow: row wrap; flex-flow: column nowrap; justify-content 成员在主轴上的对齐方式, 初始值为 flex-start, 从容器的起始点开始排列 可选值: flex-start (默认) 左对齐 flex-end 右对齐 center 居中 space-around 每个成员左右相等,但相邻的间距会合并 space-between 左右两端对齐,成员之间间距相等 space-evenly 等分 align-items 成员在交叉轴上的对齐方式, 初始值为 stretch stretch 成员没有设置&quot;高度/宽度&quot;或&quot;高度/宽度&quot;为auto时,则拉伸至整个容器的&quot;高度/宽度&quot; flex-start 在横向排列时，成员的顶部紧贴容器的顶部,不会拉伸高度 flex-start 在纵向排列时,成员的左侧紧贴容器的左侧,不会拉伸宽度 flex-end 与 flex-start 相反 flex-center 居中 baseline 让成员的对齐方式以第一行文字的基线为参照 成员属性 成员属性定义在flex容器的成员身上 order 默认值 0,该值决定了成员的排序，数值越小越靠前 order: 0 flex-grow 默认值 0，在容器还有剩余空间的情况下是否放大（无视固定宽高）, 被放大的成员会尽可能的撑满整个容器 flex-grow: 0 flex-shrink 默认值 1, 在容器剩余空间不足时，是否缩小成员 (无视固定宽高) , 0 不缩小 flex-shrink: 1 flex-basis 默认值 auto , 设置成员的宽度, 当和 width 一起使用时，权重比width高，会覆盖width flex-basis: auto align-self 默认值 auto, 默认继承容器的对齐方式。可单独设置某个成员在容器中的对齐方式 align-self: flex-start; ","link":"https://yuyang0564.github.io/l9UKVN6al/"},{"title":"数组的length","content":"数组的 length 属性返回了数组的成员个数 let arr = [1,2,3] arr.length // 3 length 属性会随着数组成员的变化而增加或减少，它是动态的。因此通过修改length 属性可以添加或删除数组的成员 let arr = [ 1, 2, 3 ] arr.length = 2 // [ 1, 2 ] let arr = [ 1, 2, 3 ] arr[arr.length] = 4 // [ 1, 2, 3, 4 ] 💡 Tip: 将字符串数值赋值给length 也是允许的 let arr = [ 1, 2, 3 ] arr.length = &quot;4&quot; ","link":"https://yuyang0564.github.io/2FfK03KOp/"},{"title":"数组的空位","content":"在创建数组时，可以使用字面量和 数组的构造函数初始化 💡 Tip: 构造函数new Array( ) 和 Array( ) 是一样的效果 let arr1 = [] let arr2 = new Array() let arr3 = Array() ES6 新增方法 Array.of( ) 也可以创建一个数组。传入的参数将作为数组的成员 Array.of() // [ ] Array.of(1,2,3) // [ 1, 2, 3 ] new Array( ) 与 Array.of( ) 的区别 new Array( ) 接收一个数值参数 时，它所创建的是一个拥有数值长度的数组，但所有位置均是空位 let arr = new Array( 5 ) // [ empty x 5 ] arr.length // 5 new Array( ) 接收一个非数值参数 或 多个数值参数 时，其表现正常 let arr = new Array(&quot;a&quot;) // [ &quot;a&quot; ] let arr = new Array(1,2,3,4) // [ 1, 2, 3, 4 ] Array.of( ) 修正了new Array( ) 接收1个数值时会创建空位数组的问题, 其他情况下表现一致 let arr = Array.of( 5 ) // [ 5 ] 数组遍历时对空位 的处理 在ES6 新增的几个方法中，能够正确识别数组的空位, 并把它当做 undefined 处理 for of let arr = Array( 5 ) for(let i of arr) { if( i == undefined ) { .... } } Array.from() let arr = Array( 5 ) Array.from(arr,item=&gt;{ if( item == undefined) { .... } }) Array.of() let arr = Array( 5 ) Array.of( ...arr ) 其余 ES5 的方法均会直接跳过 空位 forEach 、 map 、 some 、 filter 、 every .... ","link":"https://yuyang0564.github.io/nk2wQc6PW/"},{"title":"7.事件","content":"事件流 事件流用于描述页面接收事件的顺序,一共有2种分别为事件冒泡与事件捕获 1. 事件冒泡 事件从触发的元素开始逐级向上传播,一直到传播到 window &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Event Bubbling Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div onclick=&quot;clickMe&quot;&gt;Click Me&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 例: 此例中 div 的点击事件传播顺序为 div &gt; body &gt; html &gt; document &gt; window 2. 事件捕获 事件捕获正好与事件冒泡相反,它会从 window 开始最先触发事件,然后逐级下传播到具体触发事件的元素 window &gt; document &gt; html &gt; body &gt; div DOM0 级事件 🗣DOM0事件只会发生在冒泡阶段 1.HTML属性内写事件 &lt;button id=&quot;btn&quot; onclick=&quot;fn()&quot;&gt;点击事件&lt;/button&gt; 2.JS 方式写事件 var btn = document.querySelect(&quot;#btn&quot;) btn.onclick = function(){ ... } // 移除事件 btn.onclick = null DOM2 级事件 addEventListener( event , function [, useCapture] ) 参数 说明 event 事件名 function 事件处理函数 useCapture （默认）false,事件发生在冒泡阶段。 DOM2级事件的好处可以为同一个事件添加多个事件处理程序，它们会按照顺序触发 btn.addEventListener(&quot;click&quot;,()=&gt;{ console.log(1); }) btn.addEventListener(&quot;click&quot;,()=&gt;{ console.log(2); }) removeEventListener( event , function [, useCapture] ) DOM2级事件只能使用配套的方法来删除,并且需要与设置时的参数一致 鼠标事件 点击事件 事件名 说明 click 单击事件 dblclick 双击事件 mouseenter 鼠标从外部移入元素 (不冒泡) mouselave 鼠标从元素移出到外部 (不冒泡) mousemove 鼠标在元素上移动 mouseout 鼠标从触发事件的元素移动到另一个元素(可以是子元素) mousewheel 鼠标滚轮滚动 mouseup 松开鼠标按键 鼠标坐标信息 🗣 鼠标的事件对象里保存了触发事件时，鼠标的坐标信息 属性 说明 clientX 鼠标相对于浏览器视口左侧的坐标 ( 不含页面滚动 ) clientY 鼠标相对于浏览器视口顶端的坐标 ( 不含页面滚动 ) pageX 鼠标的位置距离页面左侧的坐标 ( 包含页面滚动 ) pageY 鼠标的位置距离页面顶端的坐标 ( 包含页面滚动 ) 触摸事件 touchstart 手指放在屏幕上 touchmove 手指放在屏幕上移动,连续触发。在事件中调用 preventDefault() 可以阻止页面滚动 touchend 手指离开屏幕 事件优化 事件处理程序的数量与页面整体的性能有直接的关系 1. 事件委托 主要解决为多个DOM设置相同的一类事件而占用内存 原理: 通过为所有需要设置事件的元素他们共同的祖先，绑定事件处理程序,当事件触发时，通过事件对象的 target 属性,判断当前事件触发时所在的元素 &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const ul = document.querySelect(&quot;#list&quot;) ul.addEventListener(&quot;click&quot;,(e)=&gt;{ e.target // 通过 target 判断当前触发事件时所在的元素 }) &lt;/script&gt; 2. 及时删除事件处理程序 ","link":"https://yuyang0564.github.io/xjiMc-odr/"},{"title":"5.JS盒子模型","content":"👉 classList 样式类操作 element.classList 返回了一个 DOMToKenList 集合对象，包含了元素的所有 class 类名,通过一系列方法可以实现，添加、删除、替换类名 📌 length 属性 返回类名的个数 📌 contains( className ) 验证类名是否存在 📌 item( index ) 获取第 N 个类名 📌 add( className ) 添加类名 ， 如果已经存在则忽略 📌 remove( className ) 删除类名 📌 toggle( className ) 如果类名已存在则删除，如果不存在则添加 👉 style 样式操作 任何支持style的元素节点都拥有一个style对象，该对象包含通过style为元素设置的样式 注意: 不包括css类中的样式 设置样式（设置样式时需要加上单位,否则在标准模式下会被忽略） div.style.width = &quot;20px&quot; 读取样式 div.style.width 📌 cssText 属性 可以读取/设置(覆盖写入)完整的 style 样式代码,就像在HTML中设置style一样 设置 div.style.cssText = &quot;width: 200px; heigjt: 200px&quot; 读取 📌 length 返回元素 style 的数量 div.style.length 📌 item( styleName ) 获取对应索引的样式名(样式索引从0开始)，通常与 length 结合使用 let len = div.style.length for(let i = 0; i &lt; len; i++) { div.style.item(i) } /* color width font-size */ 📌 getPropertyValue( styleName ) 通过样式名获取样式的值 📌 setProperty( styleName , value ) 追加行内样式 📌 removeProperty( styleName ) 删除一个行内样式 👉 元素的尺寸与位置 每个节点元素都有一个 getBoundingClientRect() 方法，它返回一个DOMRect 对象，包含了元素相对于视口的 width、height、left、top、bottom 属性 div.getBoundingClientRect() 👉 应用在元素上的最终样式 (只读) window.getComputedStyle( tag ) 返回一个 CSSStyleDeclaration 集合对象，包含了当前该元素在文档中最终生效的所有样式。 ","link":"https://yuyang0564.github.io/JogPwQc-l/"},{"title":"2.DOM 元素节点操作","content":"👉 节点操作 📌 document.createElement( tabName ) 创建一个元素节点。（创建的元素存在于文档之外，需要手动添加到文档节点中） 📌 document.createDocumentFragment( tabName ) 创建一个文档片段节点，它相当与一个仓库，可以用来保存即将要添加到文档中的元素节点 , 这个函数主要是用来优化。当需要向文档中添加大量节点的时候，可以把节点都暂存在文档片段中，然后一次性添加到文档，避免逐个添加时导致浏览器频繁的重绘 📌 element.appendChild( ) 将一个节点添加到 NodeList 的末尾，如果这个节点之前存在文档中，则会从之前的位置移除 📌 element.insertBefore( 插入节点 , 参照节点 ) 参照节点设置为 null , 则插入元素到末尾 var div = document.createElement(&quot;div&quot;) body.insertBefore(div,null) 插入元素到指定的节点之前 var meta = document.createElement(&quot;meta&quot;) var title = document.title head.insertBefore( meta , title ) 📌 element.insertAdjacentElement(位置字符串,要插入的元素) beforebegin :再该元素之前插入 afterend:再该元素之后插入 afterbegin : 插入到该元素中，作为第一个子元素 beforeend : 插入到该元素中，作为最后一个子元素 📌 element.removeChild( ) 从文档种移除一个节点 📌 element.cloneNode( ) 复制节点 , 返回复制节点的副本，需要手动添加到文档中 🗣 复制节点时，不会复制事件处理程序 参数为 true 时， 复制整个节点树 参数为 false 时， 只复制节点本身 ","link":"https://yuyang0564.github.io/017l4WcMs/"},{"title":"4.DOM样式操作","content":"👉 classList 样式类操作 element.classList 返回了一个 DOMToKenList 集合对象，包含了元素的所有 class 类名,通过一系列方法可以实现，添加、删除、替换类名 📌 length 返回类名的个数 📌 contains( className ) 验证类名是否存在 📌 item( index ) 获取第 N 个类名 📌 add( className ) 添加类名 ， 如果已经存在则忽略 📌 remove( className ) 删除类名 📌 toggle( className ) 如果类名已存在则删除，如果不存在则添加 👉 style 样式操作 任何支持style的元素节点都拥有一个style对象，该对象包含通过style为元素设置的样式 注意: 不包括css类中的样式 设置样式（设置样式时需要加上单位,否则在标准模式下会被忽略） div.style.width = &quot;20px&quot; 读取样式 div.style.width 📌 cssText 属性 可以读取/设置(覆盖写入)完整的 style 样式代码,就像在HTML中设置style一样 设置 div.style.cssText = &quot;width: 200px; heigjt: 200px&quot; 读取 📌 item( styleName ) 获取对应索引的样式名(样式索引从0开始)，通常与 length 结合使用 let len = div.style.length for(let i = 0; i &lt; len; i++) { div.style.item(i) } /* color width font-size */ 📌 getPropertyValue( styleName ) 通过样式名获取样式的值 📌 setProperty( styleName , value ) 追加行内样式 📌 removeProperty( styleName ) 删除一个行内样式 👉 应用在元素上的最终样式 (只读) window.getComputedStyle( tag ) 返回一个 CSSStyleDeclaration 集合对象，包含了当前该元素在文档中最终生效的所有样式。 ","link":"https://yuyang0564.github.io/c-9qBEQuz/"},{"title":"技术要点","content":"Vue vue响应式原理？过程 vue的生命周期 项目中有用到哪几个钩子函数 为什么data要设置成函数 v-model &amp; .sync v-show 和 v-if的区别 Computed和Watch 虚拟dom 虚拟dom的实现原理 虚拟dom的优缺点 vue的diff运算 Vue 路由 vue路由 路由有哪几种 几种路由的区别 路由的权限控制 Vuex vuex有哪些属性 (5大属性) 如果不用vuex有什么其它的替代方案 vuex有哪些优势和缺点 action和mutation的区别 HTML &amp; CSS3 HTML5或者css3的新特性? 新特性主要包括哪几大块？ 用到哪些新标签? canvas 响应式布局 哪几种响应式布局的方式 rem,em,px的区别 rem的实现 flex flex属性 flex实现垂直居中 flex九宫格布局 块元素有哪些 块元素和行内元素的区别和特点 空元素 (类似于img这样的单标签元素) css中有哪些属性是可以继承的 垂直居中 css动画 JS 作用域，闭包，原型链,this 闭包的使用场景 原型链的使用场景 es6 箭头函数? promise 数组 有用过数组的那些方法 怎么实现数组去重 深拷贝与浅拷贝的区别 事件的执行机制 事件的委托/代理 内存泄露 内存泄漏的场景 性能优化 重点优化... 长列表优化 浏览器 回流和重绘 两者的区别 什么场景会触发 socket通讯 2个页面怎么进行通讯 同域名的2个页面怎么通讯 不同域的2个页面怎么通讯 存储 浏览器的存储方式和区别 强缓存和协商缓存 http 常用的http状态码 常用请求头 浏览器的渲染流程 link标签和import标签的区别 跨域 解决方案 vue开发怎么配置代理 vue配置的代理属于正向代理还是反向代理 webpack 对webpack的了解 ","link":"https://yuyang0564.github.io/XODQuwICr/"},{"title":"数组遍历","content":".forEach( callback [, this ] ) 遍历每个数组元素，并调用指定的方法 没有返回值 , 不会改变原数组 callback( cur , index , arr ) cur 当前元素 index 当前元素的索引 arr 原始数组 let arr = [1, 2, 3] let arr2 = [ ] arr.forEach((item,index) =&gt; { arr2.push( item ) }) .map( callback [, this ]) 遍历每个数组元素，并调用指定的方法， 返回每个元素经过函数处理后组成的 新数组 callback( cur , index , arr ) cur 当前元素 index 当前元素的索引 arr 原始数组 let arr = [1, 2, 3] let arr1 = arr.map((item,index) =&gt; item * 2) // arr [1, 2, 3] // arr1 [2, 4, 6] .filter( callback [, this ] ) 遍历每个数组元素，并调用指定的方法， 返回每个元素经过函数处理后符合指定条件的元素组成的新数组 callback( cur , index , arr ) cur 当前元素 index 当前元素的索引 arr 原始数组 let arr = [1, 2, 3] let arr1 = arr.filter(item =&gt; item &gt; 2) // arr [1, 2, 3] // arr1 [ 3 ] .some( callback [, this ] ) 遍历每个数组元素，并调用指定的方法， 只要有一个元素经过函数调用后返回 true , 则 some 方法返回 true , 否则返回 false callback( cur , index , arr ) cur 当前元素 index 当前元素的索引 arr 原始数组 let arr = [1, 2, 3] let bool = arr.some(item =&gt; item &gt; 2) // bool -&gt; true .every( callback [ ,this ] ) 遍历每个数组元素，并调用指定的方法， 只要有一个元素经过函数调用后返回 false, 则该方法返回 false callback( cur , index , arr ) cur 当前元素 index 当前元素的索引 arr 原始数组 let arr = [1, 2, 3] let bool = arr.every(item =&gt; item &gt; 2) // bool -&gt; false .reduce( callback [, init ] ) 遍历每个数组元素，并调用指定的方法， 把所有元素调用的结果汇总为一个值 callback( cur , next , index, arr ) cur 当前元素 next 下一个元素 index 当前元素的索引 arr 原始数组 init 初始值 🗣 当没有提供 init 参数时 , callback 的 cur 为当前数组的第一项，next 为数组的第二项。下一次调用时 cur 的值为上一次返回的结果，next 为数组的第三项,以此类推 let arr = [1, 2, 3] let count = arr.reduce((cur,next)=&gt; cur + next ) 🗣 当提供了 init 参数时 , callback 的 cur 为 init 的初始值，next 为数组的第一项。下一次调用时 cur 的值为上一次返回的结果，next 为数组的第二项,以此类推 let arr = [{x: 1}, {x: 2}, {x: 3}] let count = arr.reduce((cur, next, index, arr) =&gt; { return cur + next.x }, 0) ","link":"https://yuyang0564.github.io/zbajWO59n/"},{"title":"函数","content":"📌 参数默认值 允许为参数指定一个默认值，当调用时没有传递具体的值时，将使用默认设置的值 function fn(x = 1 , y = 2) { return x + y } fn() // 3 fn(2,3) // 5 🗣 不允许重复声明 函数的参数都是默认已声明的，所以不能在内部重复声明 错误示例: // 错误 function fn( x , y) { let x = 1 } 🗣 参数的解构赋值的默认值 为解构的参数赋值一个空的对象 function fn( {x = 1 , y = 2} = { } ) { return x + y } ⚠️❗️ 当为函数指定了默认值时，length 属性将失效 function fn( {x = 1 , y = 2} = { } ) { return x + y } fn.length // 0 📌 rest 参数 它用于获取函数的所有参数 , 主要用来替换 ES5 的 arguments 对象 , rest 参数会把所有的剩余参数放入一个数组中 function fn(...rest) { let [num , str , obj] = rest /* num -&gt; 1 str -&gt; &quot;hello&quot; obj -&gt; { a: 1, b: 2} */ } fn(1, &quot;hello&quot;, { a: 1, b: 2 }) ⚠️❗️ 注意： rest 参数只能为函数参数的最后一个 , 否则会报错 // 错误示例 function fn(x , ...rest , y) { } 👉 箭头函数 🗣 基本写法 let f = (arg1,arg2) =&gt; { return arg1 + arg2 } // 类似于ES5 function f( arg1 , arg2 ) { return arg1 + arg2 } 🗣 箭头函数主要用来简化函数调用 [1,2,3].map( x =&gt; x + x ) 🗣 如果函数没有参数，则可以通过一个 “圆括号” 或 “_”和 “$” 代替参数部分 let f = () =&gt; {} let f1 = _ =&gt; {} let f2 = $ =&gt;{} 🗣 如果只有一个参数, 则可以省略“括号”( ) let f = arg =&gt; { } 🗣 如果函数体只有一条语句 ， 也可以省略 “{ }” let f = _ =&gt; &quot;hello word!&quot; 箭头函数与ES5函数区别 箭头函数内的 this 是固定的 , 它只继承上一层作用域的 “this”, 并且无法通过 call 或 apply 改变 箭头函数不可以当做 构造函数 箭头函数内部没有 arguments 对象 ","link":"https://yuyang0564.github.io/2Q_MoE1s_/"},{"title":"字符串方法","content":"📌 .includes( str, [index] ) 查找字符串中是否包含指定的字符 str : 指定的字符 index: 从索引位置开始查找 返回 true | false let str = &quot;hello word!&quot; str.includes(&quot;!&quot;) // true 📌 .startsWith( str, [index] ) 确认字符是否在字符串的开始位置 let str = &quot;hello word!&quot; str.startsWith(&quot;!&quot;) // false 📌 .endsWith( str, [index] ) 确认字符是否在字符串的结束位置 let str = &quot;hello word!&quot; str.endsWith(&quot;!&quot;) // true str.endsWith(&quot;word!&quot;) // true 📌 .repeat( num ) 字符串重复 n 次 参数会自动取整 0 ~ -1 之间会取0 ， 但是 0 会返回 “ ” x.1 ~ x.9 之间会取 x 负数 和 Infinity 无效，会导致报错 如果是字符串会使用隐式转换，如果不能正确转换为数值，则使用 0 let str = &quot;a&quot; str.repeat(1) // a str.repeat('2') // aa str.repeat(undefined) // &quot; &quot; str.repeat(null) // &quot; &quot; str.repeat(NaN) // &quot; &quot; str.repeat(1.9) // a str.repeat(-5) // &quot; &quot; ","link":"https://yuyang0564.github.io/KtGrMaQWj/"},{"title":"对象的解构赋值","content":"📌 对象的解构与数组不同，左侧的变量需要与右侧的属性同名才能成功赋值,而不是和数组一样按顺序赋值 let { foo , bar } = { foo: 'foo' , bar: 'bar' } /* foo -&gt; 'foo' bar -&gt; 'bar' */ 📌 解构失败，即未找到右侧的同名属性时。左侧变量的值为undefined let { foo , bar } = { bar : 'bar' } /* foo -&gt; undefined bar -&gt; 'bar' */ 📌 使用匹配模式 k : v k 用来匹配右侧的同名属性，赋值给 v let { bar: foo } = { bar : 'foo' } // foo -&gt; 'foo' 左侧使用bar 作为匹配右侧的条件，实际赋值给 foo变量。 此时如果试图访问 bar , 则会报出 bar is not defined 的错误 如果右侧未匹配到，或者右侧的属性严格等于 undefined 则左侧可以指定默认值 let {name , age = 10} = {name: 'Li'} /* name -&gt; 'Li' age -&gt; 10 */ let { bar : foo = 'foo' } = { abc : 'abc' } // foo -&gt; 'foo' ","link":"https://yuyang0564.github.io/bjXvTm25k/"},{"title":"数组的解构赋值","content":"📌从数组中取值，按照对应的位置依次赋值给左边的变量 let [a,b,c] = [10,20,30] /* a -&gt; 10 b -&gt; 20 c -&gt; 30 */ 只提取数组中的某个值,忽略的值用“ , ” 跳过 let [,,c] = [10,20,30] /* c -&gt; 30 */ 📌当解构不成功时，变量的值为 undefined let [foo] = [] // foo -&gt; undefined let [bar , foo] = [1] /* bar -&gt; 1 foo -&gt; undefined */ 📌当右侧的值完全等于 undefined 时， 可以为左侧的变量指定一个默认值 let [foo = 1 ] = [] // foo -&gt; 1 📌 &quot;不完全解构&quot; 等号右边的值不完全匹配左边的变量. (解构时按照位置依次向后查找) let [a,[b],c] = [1,[2,3],4] /* a -&gt; 1 b -&gt; 2 c -&gt; 4 */ 📌 等号右边不具备 &quot;Iterator&quot; 接口时，无法完成解构并会报错 let [foo] = 1 let [foo] = true let [foo] = undefined let [foo] = null let [foo] = NaN let [foo] = {} ","link":"https://yuyang0564.github.io/7diawi0BY/"},{"title":"事件","content":"👉 Event 事件对象 浏览器提供了一个 Event 对象，所有的事件都是这个对象的实例 , 它本身是一个构造函数，用来生成新的事件实例 let event = new Event( type , options ) type 参数为事件名 options 是一个可选对象，有 2 个可选配置 （ 如果忽略默认会在“捕获”阶段触发 ） 属性 值 bubbles 事件是否冒泡 true / false (默认) cancelable 事件是否能被取消 true / false(默认) let event = new Event(&quot;click&quot;,{ bubbles: true, canclelable: false }) 通过 dispatchEvent( ) 用来触发一个事件 let event = new Event(&quot;click&quot;) let div = document.querySelect(&quot;div&quot;) div.dispatchEvent(event) // div 元素上触发一个 click 事件 👉 事件模型 DOM0 级事件模型 DOM2 级事件模型 区别 DOM0 级事件使用 on 绑定 elementObject.onclick = function() { ... } 🗣 定义的事件在传播时只能 “冒泡” 🗣 在一个对象上绑定多个相同的事件时，最后一个会覆盖之前的 🗣 解除事件时，需要把事件处理函数替换为 “null” elementObject.onclick = null DOM2 级事件使用 addEventListener( ) 绑定 elementObject.addEventListener(&quot;click&quot;, function(){ ... }, false) 🗣 第三个参数默认为 false , 即以 “冒泡”的方式传播 。 设置为 true 时，以 “捕获”的方式传播 🗣 在一个对象上绑定多个相同的事件时，会按照绑定的顺序依次触发 🗣 解除事件时，需要通过 removeEventListener( ) 。 ！！ 注： removeEventListener( ) 只能解除 addEventListener( ) 绑定的事件 elementObject.removeEventListener(&quot;click&quot;, function(){ ... }, false) 👉 事件的传播机制 DOM2 在定义事件时，规定一个事件的传播需经过 3个阶段 从 window 对象开始逐步向下传播至目标节点 (“捕获阶段”) 在“目标节点”上触发事件 从“目标节点”向上传播回 window （“冒泡阶段”） 👉 事件代理 基于事件传播的特性，把原本需要在子元素上响应的事件，委托给上级元素，由上级元素负责监听事件, 通过 event事件对象 中的target属性，判断触发事件的子元素 ","link":"https://yuyang0564.github.io/1QYV9xp2Y/"},{"title":"3.Element ","content":"👉 Element 类型定义了元素的类型与访问 🗣 可以通过判断 nodeType 来确认一个节点是否为【元素节点】 nodeType 类型 1 元素节点 3 文本节点 9 body 11 文档片段 🗣 通过 tagName 获取元素名 ( 注意： 返回的是大写 ) if(document.body.tagName == &quot;BODY&quot;) { .... } 所有元素节点共有的标准属性 (可读，可写) 属性 说明 id 唯一标识 title 鼠标移入的提示 name 为标签定义名称 className 类名(由于class为系统关键字，所以使用className) 📌 getAttribute( ) 获取元素的 html属性 与 自定义html属性 。针对不存在的属性返回 null 📌setAttribute( ) 设置元素的 html属性 与 自定义html属性 。针对不存在的属性则会写入，已经存在的会替换 📌removeAttribute( ) 删除元素的 html属性 与 自定义html属性 &lt;h1 class=&quot;h1&quot;&gt;&lt;/h1&gt; var div = document.getElementByTagName(&quot;h1&quot;).item(0) h1.getAttribute(&quot;class&quot;) // 获取class类名时，使用class h1.setAttribute(&quot;id&quot;,&quot;h1&quot;) h1.setAttribute(&quot;name&quot;,&quot;h1&quot;) h1.setAttribute(&quot;data-test&quot;,&quot;test&quot;) 通过 getAttribute() 与 DOM 对象属性 的方式访问属性，主要存在2大区别： 元素的 style 1.通过 getAttribute() 获得的style，只返回字符串 2.通过 element.style 方式，返回 cssStyle 对象 事件 1.通过 getAttribute() 读取事件，只返回字符串 2.通过element读取事件，返回具体的事件函数 ","link":"https://yuyang0564.github.io/YbVoeZETF/"},{"title":"1.DOM 节点","content":"👉 Document 节点 document 在浏览器中属于 window 的一个属性，用来表示整个文档 👉 document 中内置了一些常用的属性 属性 说明 body 获得 body 的引用 documentElement 获得 html 的引用 title 网页的标题( 可读/写) URL 获得 url 👉 节点之间的关系 节点之间的关系可以通过家族关系的方式来描述，html 是最外层元素，可以认为是所有元素的根元素 , body 和 head 等是平级关系，可以认为它们是兄弟关系 等等... 元素节点还拥有一个childNodes属性， 它保存的是一个 NodeList 对象，里面包含了该元素的所有子元素 🗣 NodeList 对象是一个伪数组，它拥有 length 属性 ， 它的值为子元素的个数 NodeList 是动态的，它的值是基于当前的查询结果 元素节点拥有一个 parentNode , 指向它的父节点 元素节点拥有一个 previousSibling 和 nextSibling 属性，分别指向前一个 和 后一个 兄弟节点 🗣 第一个元素的 previousSibling 的值，和最后一个元素的 nextSibling 的值为 NULL 每一个节点拥有一个 ownDocument 属性，指向整个文档 元素选择器（只列出常用的几种） 👉 由 document 调用 📌 getElementById( ) 通过 &quot; id &quot; 属性名获取元素 📌 getElementByTagName( tagName ) 通过 &quot; 元素名 &quot; 获取元素, 返回一个 HTMLCollection 集合对象，它与 NodeList 相似 🗣 HTMLCollection 对象有一个 namedItem( ) 方法， 可以获得集合中指定 name属性的元素, 如果多个元素有相同的 name 属性， 则获取排在首位的那个元素 &lt;p&gt;&lt;/p&gt; &lt;p name=&quot;p2&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; var collcation = document.getElementsByTagName(&quot;p&quot;) collcation.namedItem(&quot;p2&quot;) // &lt;p name=&quot;p2&quot;&gt;&lt;/p&gt; 👉 由 元素节点 或 document 调用 querySelect( ) 根据 【css类名\\id\\元素名\\元素属性】选择一个元素 ( 可以通过 document 调用，或该元素的父元素调用) &lt;ul&gt; &lt;li id=&quot;li&quot;&gt;&lt;/li&gt; &lt;/ul&gt; /* 以下方法都可以获取到 &lt;li&gt; 元素 let li = document.querySelect(&quot;#li&quot;) let ul = document.querySelect(&quot;ul&quot;).querySelect(&quot;#li&quot;) */ querySelectAll( ) 根据 【css类名\\id\\元素名\\元素属性】选择元素 , 返回 NodeList 对象集合 👉 元素节点共有 children 返回所有子元素节点 (HTMLCollection 对象集合) childElementCount 返回子元素节点的数量 firstElementChild 返回第一个子元素节点 lastElementChild 返回最后一个子元素节点 previousElementSibling 返回前一个同辈元素节点 nextElementSibling 返回后一个同辈元素节点 ","link":"https://yuyang0564.github.io/jNezF_qOD/"},{"title":"原型对象/原型链","content":"👉 原型对象 每一个函数都有一个 prototype 属性，它引用了一个对象 , 这个对象就被称为 原型对象 。 原型对象的作用 原型对象中可以包含共享的【属性】与【方法】（由这个函数创建的所有实例） 🗣 &quot;原型对象&quot; 中初始只有一个 constructor 属性， 它默认指向 &quot;当前构造函数&quot;。 🗣 通过该函数生成的实例中会包含一个 【proto】 属性 , 这个属性指向 &quot;构造函数&quot; 的原型对象 🗣 由此得出结论， 【原型对象】 连接了 &quot;构造函数&quot; 和 &quot;实例&quot; 📌 Object.getPrototypeOf( ) 可以返回一个实例指向的 &quot;原型对象&quot; let num = 1 Object.getPrototypeOf( num ) 属性/方法的访问原则 当访问一个实例的 属性/方法 时， 会优先从实例本身开始查找，如果实例中没有，则会去实例的 _ proto _ 所指向的 &quot;原型对象&quot; 中查找。 实例 【属性/方法】的遮蔽性 如果实例存在与 &quot;原型对象&quot; 中同名的&quot;属性/方法&quot; ， 则会遮蔽对&quot;原型对象&quot;中同名&quot;属性/方法&quot;的访问。 只有通过 delete 删除实例中同名&quot;属性/方法&quot;，才能恢复对&quot;原型对象&quot;中同名&quot;属性/方法&quot;的访问 📌 通过实例继承的 hasOwnProperty( ) 可以确定一个属性是在实例还是&quot;原型对象&quot;中 , 它对存在于实例中的属性返回 true let str = &quot; &quot; str.hasOwnProperty( constructor ) // false 👉 原型链 由于javascript 是基于原型的继承，任何一个对象都可以充当其他对象的原型，而对象本身又存在一个隐式原型【_ proto _】它也是一个对象指向它的原型对象，这样一直向上追溯就形成了类似链条一样的关系，这就是 &quot;原型链&quot; 。原型链会一直追溯到 Object.prototype , 而它的上层就是Null,也就是&quot;原型链&quot;的尽头 👉 原型链的作用 &quot;原型链&quot; 实现了属性访问的规则，当访问一个 属性/方法 时， 会优先从实例本身开始查找，如果实例中没有，则会去实例的 _ proto _ 所指向的 &quot;原型对象&quot; 中查找 ， 依照这样的规则一直查找到 &quot;原型链&quot;的顶端 。如果未找到，则返回 undefined ","link":"https://yuyang0564.github.io/QINp3oP4V/"},{"title":"执行环境(作用域)","content":"👉 执行环境决定了 变量或 函数 访问数据的范围 执行环境又分为 全局 和 函数 在 Web 浏览器中，全局为 &quot;window&quot; , 在 NODE 中， 全局为 &quot;global&quot; 每个&quot;执行环境&quot; 都有一个 变量对象 , 一个环境中的所有变量与函数都保存在这个对象中 📌 当进入一个 &quot;环境&quot; 时，会创建一个作用域链，它的作用是确保从执行环境中正确的访问数据。作用域链的最前端是当前执行环境的&quot;变量对象&quot;. 如果当前执行的环境是 &quot;全局&quot; ，则&quot;变量对象&quot;为 window [ window ] 如果当前执行环境是 &quot;函数&quot; , 则最前端的&quot;变量对象&quot;为当前函数的 arguments 💡 ( 帮助理解，可以把&quot;作用域链&quot;想象成数组， 当前已激活作用域的 &quot;变量对象&quot;始终在数组的最前方，全局的&quot;变量对象&quot;在数组的最末尾 ) [ arguments , arguments ....... , window ] 在一个环境中查找变量就是沿着这样一个 &quot; 作用域链 &quot; , 一级一级的向后搜索 ","link":"https://yuyang0564.github.io/X3aiegO5c/"},{"title":"类型检测","content":"👉 typeof 主要用来检测一个值是 基本类型 还是 引用类型 类型 检测 String &quot;string&quot; Number &quot;number&quot; Boolean &quot;boolean&quot; undefined &quot;undefined&quot; 除了以上会返回对应的基本类型 表示的字符串，其余均返回 &quot;object&quot; 📌 特殊： 对函数使用 typeof 会返回 &quot;function&quot; 👉 instanceof 确定对象的类型 由于所有引用类型 都是 Object 类型的实例，所以在检测所有&quot;引用类型&quot; 是不是 &quot;Object&quot; 类型的实例时，始终返回 true [ ] instanceof Object { } instanceof Object 检测数组类型 [] instanceof Array 检测正则类型 \\\\ instanceof RegExp ","link":"https://yuyang0564.github.io/tkbkLazjo/"},{"title":"switch 语句","content":"switch 属于流程控制语句 switch (expression) { case value: statement break; case value: statement break; default: statement } 👉 说明 switch 语句中的每一个 case 的含义是：“如果表达式等于这个值（value），则执行后面的 语句（statement）”。 通过 break 关键字跳出 switch 语句。 如果省略 break 关键字，就会再执行完当前 case 后，继续执行下一个 case。 default 关键字则用于在表达式不匹配前面任何一个case时候，执行的默认代码 ❗️ ❗️ 特别注意 case 不会发生隐式转换，它默认使用全等( === ) 操作符与 switch 的值进行比较 ","link":"https://yuyang0564.github.io/9HbicUlds/"},{"title":"数值转换","content":"👉 NaN NaN是一种特殊的数值，用来表示即将要返回数值的操作数，最终返回的不是一个数值 ❗️❗️ 注意： &quot; NaN &quot; 不能用来比较，它与任何类型的值都不相等，包括它自身 👉 3种数值转换 📌 Number() Number() 可以转换任何数据类型 类型 规则 Boolean true =&gt; 1 , false =&gt; 2 Number 原样返回 null 0 undefined NaN String 1. 空字符串转为 0 。 2. 转为 10 进制 , 忽略前导 0 , 从字符串的开头逐位匹配直到非数值,如果字符串的开头就是非数值, 则直接返回 NaN 📌 parseInt() 用于字符串格式的数值转为 &quot; 整数 &quot; , 忽略空格 对&quot;空字符串&quot;返回 NaN 默认转为 10 进制 , 忽略前导 0 , 从字符串的开头逐位匹配直到非数值 忽略浮点类型的小数点( . ) 📌 parseFloat() 忽略前导0 。 只识别第一个小数点( . ) 。 &quot;23.45.45&quot; =&gt; 23.45 如果是整数或者小数点后全是0，则转为 &quot; 整数&quot; 。 &quot;23&quot; =&gt; 23 &quot;23.0000&quot; =&gt; 23 ","link":"https://yuyang0564.github.io/FKgYxSmal/"},{"title":"ES5 数据类型","content":"👉 # 五种基本类型 📌 Undefined 已声明但未赋值的变量默认值为 &quot; Undefined &quot; &quot; Undefined &quot; 是 &quot; Null &quot; 的子集，所以 undefined == null 📌 Null 表示一个空对象的指针 null 只有一个值为它自身， 所以 null === null 📌 Boolean 只有 2 个字面值 true 和 false , 且区分大小写 所有的数据类型都可以被 Boolean 转换 数据类型 转换为 true 转换为 false Boolean true false String 非空字符串 &quot; &quot; , ' ' Number 非 0 数值 0 和 NaN Undefined x undefined Object 任何引用类型 null 📌 Number 表示 &quot;整数&quot; 和 &quot;浮点数&quot; 在数值类型中， +0 和 -0 是相等的 &quot; 浮点数 &quot;的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1+0.2 的结果不是 0.3，而是 0.30000000000000004 📌 String 由单引号 ( ' ) 或 双引号 ( &quot; ) 包裹的字符序列组成 ♻️ 任意类型转字符串只需要与 &quot; &quot; 相加 ( + ) 👀 转义字符 (非打印字符) 字面量 含义 \\r 回车 \\n 换行 \\t 制表符 \\b 空格 toString() 方法 将任意类型转为字符串表示, ❗️❗️注： &quot;null&quot; 和 &quot;undefined&quot; 没有此方法 数据类型 转换规则 Boolean &quot;true&quot; 和 &quot;false&quot; Number &quot;number&quot; String 原样返回 Array 以 逗号 ( , ) 分隔的字符串(或空字符串) Object &quot;[object Object]&quot; Function 函数体原样输出 String() 方法 转换规则与 &quot; toString() &quot; 一致 唯一区别可以将 &quot; null &quot; 和 &quot;undefined&quot; 正确的转为字符串 类型 转换规则 null &quot;null&quot; undefined &quot;undefined&quot; 👉 # 一种引用类型 📌 Object Object 类型是所有实例 最终的基类,所以绝大部分实例都继承了它公有的方法 方法 用途 hasOwnProperty() 检查一个属性是属于对象的实例还是原型 isPrototypeOf() 检查传入的对象是否是调用者的原型 toString() 该对象的字符串表示 ","link":"https://yuyang0564.github.io/5t5zxcYsk/"},{"title":"Vue slot","content":"👉 slot 是组件的一块HTML模板，这块模板显示的内容由外界决定 👴 父组件中为子组件的slot 传值，传入的任何内容都会替换slot &lt;div id=&quot;app&quot;&gt; &lt;child-component&gt;传入一段文本替换slot&lt;/child-component&gt; &lt;/div&gt; &lt;script&gt; ... data() { return { num: 1 } }, components: { listComponent } &lt;/script&gt; 👶 子组件中通过定义 slot 来接收外界传入的内容 &lt;!-- export child-component --&gt; &lt;h1&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt; 最终会渲染为 📽 👉 插槽也可以定义默认值，当外界没有传入内容时，会使用插槽的默认值 &lt;!-- export child-component --&gt; &lt;h1&gt; &lt;slot&gt;这是子组件插槽的默认值&lt;/slot&gt; &lt;/h1&gt; 👉 在插槽内使用变量 使用规则: 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 在父级模板中替换插槽时，只能访问父级作用域 &lt;div id=&quot;app&quot;&gt; &lt;child-component&gt; {{ num }} &lt;/child-component&gt; &lt;/div&gt; /* ... data() { return { num: 0 } } ... */ 👉 具名 slot 当定义了多个 slot 时， 可以通过设置 name属性，为 slot 定义名称 &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; 不含有 name属性 的 slot ， 默认会带有一个隐含的 name 属性，值为 &quot;default&quot; （只能有 1 个） &lt;slot&gt;&lt;/slot&gt; &lt;!-- 等价于 --&gt; &lt;slot name=&quot;default&quot;&gt;&lt;/slot&gt; 👉 替换具名 slot 替换具名 slot ， 需要在 &lt;template&gt; 上使用 v-slot:name , 根据插槽的名称替换 name。 🗣 v-slot:name 简写 #name &lt;slot name=&quot;header&quot;&gt;...&lt;/slot&gt; &lt;!-- 替换 &quot;header&quot; 插槽 --&gt; &lt;template v-slot:header&gt;...&lt;/template&gt; &lt;!-- 简写 --&gt; &lt;template #header&gt;&lt;/template&gt; 👉 作用域插槽 当在父组件中替换插槽时，只能访问父组件中的数据 // 父组件 &lt;div&gt; &lt;template #default&gt; &lt;p&gt;{{ num }}&lt;/p&gt; &lt;/template&gt; &lt;/div&gt; /* ... data() { return { num: 0 } } ... */ 但是我们可以把子组件中的某个数据绑定到插槽上,让父组件使用。通过 v-bind:propname=&quot;prop&quot; // 子组件 &lt;span&gt; &lt;slot :time=&quot;time&quot;&gt;&lt;/slot&gt; &lt;/span&gt; /* ... data() { return { time: '1990-01-01' } } ... */ 父组件访问插槽绑定的数据时, 通过 v-slot:name=&quot;propname&quot; , 其中 propname 的名称可以自定义 , &lt;div&gt; &lt;template v-slot:default=&quot;Obj&quot;&gt; {{ Obj.time }} &lt;/template&gt; &lt;/div&gt; /* 父组件的自定义 propname 相当于 propname = { time: 'xxx' } */ // 简写 &lt;div&gt; &lt;template #default=&quot;Obj&quot;&gt; {{ Obj.time }} &lt;/template&gt; &lt;/div&gt; 当然如果子组件绑定的数据是 map 类型，还可以解构出来 // 子组件 &lt;span&gt; &lt;slot :user=&quot;user&quot;&gt;&lt;/slot&gt; &lt;/span&gt; /* ... data() { return { user: { name: &quot;xx&quot;, age: 10 } } } ... */ /*---------------------------------分隔线-------------------------------*/ // 父组件 &lt;div&gt; &lt;template #default=&quot;{user}&quot;&gt; {{ user.name }} {{ user.age }} &lt;/template&gt; &lt;/div&gt; ","link":"https://yuyang0564.github.io/V__VfydC-/"},{"title":"Vue prop","content":"子组件是通过 props 配置接收父组件传递的数据 export default { props: { list: [] } } 👉 除了 静态字符串 , 其他任意值都需要通过绑定属性的方式传递值 &lt;child-component v-bind:list=&quot;list&quot; /&gt; &lt;!-- 静态字符串 --&gt; &lt;child-component str=&quot;abc&quot; /&gt; &lt;!-- boolean --&gt; &lt;child-component v-bind:bool=&quot;true&quot; /&gt; &lt;!-- 数值 --&gt; &lt;child-component v-bind:num=&quot;10&quot; /&gt; 👉 如果想把一个对象的所有属性都传递给子组件 , 可以直接通过 v-bind 绑定一个对象 ... data = { id: 1, name: &quot;li&quot; ... } &lt;child-component v-bind=&quot;data&quot; /&gt; 单向数据流 父子之间通过 prop 形成了一个单向下行绑定。 父级的数据更新时会自动同步到所有的子组件中，但是不能直接在子组件中直接修改 prop 数据。这样会导致其他用到此数据的组件也发生改变 Prop 验证 可以通过为prop定义类型验证,当传入的值不满足要求时,浏览器会再控制台中提示错误信息 配置为 object 类型 export default { props: { list: { type: Array, default() { return [] }, required: true, validator(param) {} } } } type 用于定义类型 : String , Number , Boolean , Array , Object , Date , Function , Symbol default 用于定义默认值 : 如果该 prop 为引用类型，则应该通过一个函数返回 required 用于定义是否为必传项 : true | false validator 通过自定义函数验证 prop : 自定义函数接收的唯一参数就是 prop 非 prop 属性 当父组件传递数据给子组件 , 但是子组件没有定义 prop 来接收数据时， 父组件传递的数据会被添加到子组件的 根节点 上 👨 父组件 &lt;child-component v-bind:num=&quot;10&quot; /&gt; 👶 子组件未定义props 接收此数据时，会被渲染为 &lt;div num=&quot;10&quot;&gt; ... &lt;/div&gt; ","link":"https://yuyang0564.github.io/W5Qxj_AEr/"},{"title":"Vue v-model","content":"在表单类型中可以通过 v-model 来创建双向数据绑定 它会忽略表单元素 value 、 selected 、 checked 的初始值 ，而使用 v-model 绑定的数据作为初始值 &lt;input v-model=&quot;inputValue&quot; /&gt; export default { data() { return { inputValue: &quot; &quot; } } } v-model 是一个语法糖🍡，实际上它在底层监听用户的输入事件并更新数据 针对 text 和 textarea 的 input，监听 input 事件， 同步 value 属性 针对 checkbox 和 radio 的 input , 监听 change 事件 , 同步 checked 属性 针对 select 元素 , 监听 change事件 ， 同步 value 属性 checkbox ☕️ &lt;div&gt; &lt;label for=&quot;a&quot;&gt;A&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;a&quot; value=&quot;A&quot; v-model=&quot;checkboxList&quot;&gt; &lt;label for=&quot;b&quot;&gt;B&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;b&quot; value=&quot;B&quot; v-model=&quot;checkboxList&quot;&gt; &lt;label for=&quot;c&quot;&gt;C&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;c&quot; value=&quot;C&quot; v-model=&quot;checkboxList&quot;&gt; &lt;/div&gt; export default { return { checkboxList: [ ] } } radio ☕️ &lt;div&gt; &lt;label for=&quot;a&quot;&gt;A&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;a&quot; value=&quot;selectA&quot; v-model=&quot;radio&quot;&gt; &lt;label for=&quot;b&quot;&gt;B&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;b&quot; value=&quot;selectB&quot; v-model=&quot;radio&quot;&gt; &lt;label for=&quot;c&quot;&gt;C&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;c&quot; value=&quot;selectC&quot; v-model=&quot;radio&quot;&gt; &lt;/div&gt; export default { return { radio: &quot; &quot; } } textarea ☕️ &lt;div&gt; &lt;textarea v-model=&quot;text&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; select ☕️ &lt;div&gt; &lt;select v-model=&quot;select&quot;&gt; &lt;option value=&quot;&quot; disabled selected&gt;未选择&lt;/option&gt; &lt;option &gt;选择一&lt;/option&gt; &lt;option &gt;选择二&lt;/option&gt; &lt;option &gt;选择三&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; 针对 select , 最好提供一个 disabled 的 option , 同时 value 为空，以提供默认值 当没有为 option 提供 value 属性时， 会把 option 的值作为 value 的值 ... &lt;option &gt;选择一&lt;/option&gt; ... &lt;!-- 当选中时， value 的值为 &quot; 选择一 &quot; --&gt; ","link":"https://yuyang0564.github.io/tFKRiinFM/"},{"title":"scss  运算符 \" / \"","content":"/ 运算符通常情况下会被识别为 css 中的 “分隔”, 所以在被当作 “除法”运算符时，需要使用 ( ) 进行包裹 .box { width: (10 / 2) + px; } .box { width: (10px / 2); } $width: 10px; .box { width: ($width / 2); } ❗️❗️ 注意： 如果两个带有单位的数值直接相除时， 得到的值 &quot;没有单位&quot; .box { width: (10px / 2px); } 转换为 css .box { width: 5; } ","link":"https://yuyang0564.github.io/NtrhYJ8BR/"},{"title":"scss  运算符 \" + \" ","content":"+ 运算符 👈 + 运算符可以用做数值的运算 .box { width: 10px + 10px; } .box { width: 10 + 10px; } 作为运算符时，最好使用 ( ) 包裹一下，避免被当作连接符 .box { width: (10 + 10) + px; } + 运算符也可以用来连接字符串 .box { width: (10 + 10)+px; } 👉 如果数值与含有 &quot; &quot; （引号）的字符串连接, 则输出的是含有 （引号）的字符串 .box { width: (10 + 10) + &quot;px&quot;; } .box { width: &quot;20px&quot;; } 👉 如果2个字符串连接 , + 号的左侧不含 &quot; &quot; （引号）, 右侧含有 &quot; &quot; （引号）, 则输出时不含（引号） .box { font-family: 微软 + &quot;雅黑&quot;; } .box { font-family: 微软雅黑; } 👉 如果2个字符串连接 , + 号的右侧不含 &quot; &quot; （引号）, 左侧含有 &quot; &quot; （引号）, 则输出时含（引号） .box { font-family: &quot;微软&quot; + 雅黑; } .box { font-family: &quot;微软雅黑&quot;; } ","link":"https://yuyang0564.github.io/fAzNecyHB/"},{"title":"scss @extend","content":"@extend 继承样式 👈 @extend 主要用来继承选择器的样式 .color { font-size: 100%; color: #ff0000; } // 在 .box 类中继承 .color 类的所有样式 .box { @extend .color; } ","link":"https://yuyang0564.github.io/5ztAe1rR9/"},{"title":"scss  @mixin","content":"@mixin 混合器 👈 混合器的作用是把可以重用的代码单独抽离出来，作为可复用的代码，以混入其他的样式中 混合器使用 @mixin 关键字定义，后面跟上样式代码块定义的名称 @mixin border { border: 1px solid #000; outline: 0 none; } 使用 @include 引入混合器 .box { @include border; } 混合器规则 👈 css 样式 @mixin border { font-size: 100%; } css 匹配规则 @mixin li-style { font-size: 100%; li { list-style: none; } } 可以传参的混合器 👈 可以传参的混合器,类似于 function , 在引用时需要严格对应指定的参数 @mixin li-style($color,$bgc) { color: $color; background-color: $bgc; } li { @include li-style(#ff000,red); } ","link":"https://yuyang0564.github.io/DyYlP5Spv/"},{"title":"资源/工具","content":"animate.css reset.css ","link":"https://yuyang0564.github.io/jGofPocsp/"},{"title":"css 垂直居中","content":"通过 块元素 的 &quot;before&quot; 伪类实现垂直居中 为父元素的伪类设置为 &quot;inline-block&quot; , 并设置 &quot;vertical-align: middle&quot; .parent:before { content: &quot;&quot;; display: inline-block; vertical-align: middle; height: 100%; } 子元素 同理 因为 子元素 被转为了 inline-block , 所以相互之间会有一定的间隙 设置 父元素 的 &quot;font-size&quot; 为 0 ，即可解决 .parent { ... font-size: 0; } 通过 定位 垂直居中，同水平居中的定位方法(改变偏移的方向即可) 通过 flex 垂直居中 .parent { display: flex; align-items: center; } ","link":"https://yuyang0564.github.io/HN4j53ksu/"},{"title":"css 水平居中","content":"块元素水平居中1 在块元素有固定宽度, 并且宽度非 100%时，可以通过左右的 margin 设置为 auto ， 来使块元素水平居中 &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt; &lt;/div&gt; .box1 { width: 50%; margin: 100px auto; text-align: center; } 块元素水平居中2 父元素 设置为 &quot;相对定位&quot; , 子元素 设置为 &quot;绝对定位&quot; 子元素 向左偏移 50% 子元素 有宽度时通过 &quot; margin-left &quot; 自身宽度的一半 .con { width: 100%; height: 250px; background-color: #fc5c5c; position: relative; } .box1 { width: 200px; height: 200px; background-color: #c6c6c6; position: absolute; left: 50%; margin-left: -100px; } 子元素 未定义宽度时 ， 通过 transform: translateX 向 X 轴偏移 50% .con { width: 100%; height: 250px; background-color: #fc5c5c; position: relative; } .box1 { background-color: #c6c6c6; position: absolute; left: 50%; transform: translateX(-50%); } 元素转为 inline-block 在父元素是块元素时, 把子元素转为 inline-block 并通过设置 text-align 属性来使元素水平居中 需要注意的是， inline-block 之间的元素是有一定间隙的 ， 可以通过为 包裹层 设置 font-size 为 0 来解决元素之间有间隙的问题 &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;1&lt;/div&gt; &lt;/div&gt; .con { background: #fc5c5c; text-align: center; font-size: 0; } .box1,.box2 { width: 50px; height: 50px; display: inline-block; font-size: 16px; background: #e0cd } 通过 flex 设置任意元素的水平居中 .box1 { background-color: #c6c6c6; display: flex; justify-content: center; } ","link":"https://yuyang0564.github.io/SfWYj_E84/"},{"title":"css position","content":"position 为元素设置定位 每个定位的元素可以设置 top , left , right , bottom 属性，决定元素的位置 relative 相对定位 relative 是相对于元素当前的位置启用定位。 不会改变元素的原始样式。 定位的元素不会发生位置的偏移 。 &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; .box1 { width: 100px; height: 100px; background: #ff0000; } .box2 { width: 100px; height: 100px; background: #c0c; position: relative; } 对 inline 元素设置相对定位后，并不会改变元素的默认样式 &lt;span class=&quot;test&quot;&gt;inline 元素设置相对定位&lt;/span&gt; .test { position: relative; width: 200px; height: 200px; background: #c0c0c0; } absolute 绝对定位 绝对定位元素的位置是相对于最近的已定位父元素，如果没有已定位的父元素，那么它的位置相对于 body 绝对定位会使元素脱离文档流 , 不再占据文档中的位置 如果该元素没有设置宽，高，则宽，高为auto &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt; &lt;/div&gt; .con { width: 200px; height: 200px; background-color: #fc5c5c; margin: 50px 0 0 50px; } .box1 { position: absolute; left: 10px; top: 10px; width: 200px; } fixed 固定定位 固定定位的元素是相对于窗口进行定位 , 它的位置是固定的。即使浏览器发生滚动行为，它的位置也不会发生变化 固定定位同样会使元素脱离文档流,不再占据页面的空间 如果该元素没有设置宽，高，则宽，高为auto ","link":"https://yuyang0564.github.io/UPDgIH1zK/"},{"title":"Vue 事件处理","content":"v-on 用于监听事件， 简写 @ v-on:click=&quot;事件处理函数&quot; @click=&quot;事件处理函数&quot; &lt;div v-on:click=&quot;handleClick&quot;&gt;点击事件&lt;/div&gt; 事件处理函数接收一个默认参数为“原生事件对象” handleClick(event) {...} 为事件传递参数 &lt;div v-on:click=&quot;handleClick('attribute')&quot;&gt;点击事件&lt;/div&gt; 同时传递 event 事件对象 ， 通过特殊的变量 $event &lt;div v-on:click=&quot;handleClick('attribute',$event)&quot;&gt;点击事件&lt;/div&gt; 执行多个事件处理函数 &lt;div @:click=&quot;handleClick('attribute',$event),handleClick2('attribute',$event)&quot; &gt;点击事件&lt;/div&gt; 注意： 执行多个事件处理函数时,必须显式的传入参数,没有默认 event 参数 事件修饰符 .stop 阻止事件冒泡 .prevent 阻止事件默认行为 .capture 事件使用捕获 .self 只有再触发事件的元素为自身时才调用处理函数 .once 只触发一次就销毁事件 ","link":"https://yuyang0564.github.io/1Q4Y64TAs/"},{"title":"Vue 条件渲染","content":"通过 v-if 指令 ，只有在表达式的值为 true 时 ， 元素才会显示 v-if 是惰性的 , 如果初始值为 false 时，元素并不会被渲染 &lt;h1 v-if=&quot;isShow&quot;&gt;标题&lt;/h1&gt; isShow: true v-else 相当于 if - else v-else-if 相当于 if - else if - else 注意!!!! 👈👈👈 在使用 v-else-if ， v-else 时必须紧跟在一起 ❌ 错误示例 &lt;h1 v-if=&quot;isShow&quot;&gt;...&lt;/h1&gt; &lt;h1&gt;...&lt;/h1&gt; &lt;h1 v-else&gt;&lt;/h1&gt; 通过 template 控制整块元素的显隐 &lt;template&gt; 不会渲染为元素 ， 所以可以当作一个包裹层 &lt;template v-if=&quot;isShow&quot;&gt; &lt;div&gt;...&lt;/div&gt; &lt;/template&gt; v-show 它与 v-if 在用法上大致一样, 但是 v-show 的元素始终会保留 DOM ， 只不过为元素设置了 display 属性 ","link":"https://yuyang0564.github.io/Ebj0LLIpd/"},{"title":"Vue class 与 style 绑定","content":"对象语法 &lt;span :class=&quot;{active: isActive}&quot;&gt;&lt;/span&gt; 是否应用 &quot;active&quot; 这个类名，取决与数据对象&quot;isActive&quot; 是否为true 对象语法2 &lt;span :class=&quot;classObject&quot;&gt;&lt;/span&gt; classObject: { active: true, isShow: true } 通过一个对象一次控制多个类名 最终显示为 &lt;span class=&quot;active isShow&quot;&gt;&lt;/span&gt; 数组语法 &lt;span :class=&quot;[activeClass , isShowClass]&quot;&gt;&lt;/span&gt; 绑定的类名取数据对象 &quot;activeClass&quot; , &quot;isShowClass&quot; 的值 activeClass: &quot;active&quot;, isShowClass: &quot;show&quot; 最终显示为 &lt;span class=&quot;active show&quot;&gt;&lt;/span&gt; 其他用法 三元表达式判断应用类名 &lt;span :class=&quot;[activeClass ? active : '']&quot;&gt;&lt;/span&gt; 数组语法中包含对象语法 &lt;span :class=&quot;[ {active: }]&quot;&gt;&lt;/span&gt; ","link":"https://yuyang0564.github.io/tOMZ6OxlC/"},{"title":"Vue 指令","content":"Vue 指令以 v- 开头 ，它是一种特殊的属性，它的值为一个表达式 &lt;span v-if=&quot;isTrue&quot;&gt;&lt;/span&gt; v-bind: 指令，用来动态的绑定属性 &lt;span v-bind:href=&quot;url&quot;&gt;&lt;/span&gt; 绑定一个 href 属性，它的值为 url 数据对象的值 动态参数 &lt;span v-bind:[attribute]=&quot;url&quot;&gt;&lt;/span&gt; 针对attribute 求值后，作为属性使用 注意： 不能使用 空格 和 引号 &lt;span v-bind:[attribute + 'xxx' ]=&quot;url&quot;&gt; 错误示例 &lt;/span&gt; v-bind 简写 &lt;span :href=&quot;url&quot;&gt;&lt;/span&gt; &lt;span :[attribute]=&quot;url&quot;&gt;&lt;/span&gt; v-on: 指令 , 用来绑定事件 &lt;button v-on:click=&quot;handleClick&quot;&gt;&lt;/button&gt; 为当前 button 绑定一个 click 事件， 事件处理方法为 &quot; handleClick&quot; 动态绑定事件 &lt;button v-on:[eventHandle]=&quot;handleClick&quot;&gt;&lt;/button&gt; 针对 eventHandle 求值后，作为事件名 v-on 简写 &lt;span @click=&quot;handleClick&quot;&gt;&lt;/span&gt; &lt;span @[attribute]=&quot;url&quot;&gt;&lt;/span&gt; ","link":"https://yuyang0564.github.io/gb9VgBmPf/"},{"title":"Vue2 模板语法","content":"vue 中使用了 &quot;Mustache&quot; 插值表达式 (双大括号) &lt;span&gt;{{ msg }}&lt;/span&gt; msg 对应数据对象， 只要msg 发生变动，页面上的显示会自动更新 显示原始 HTML 由于 &quot; {{ }} &quot; 会把数据解析成文本，所以在要输出原始HTML的元素上使用 v-html 而非使用插值表达式 {{ }} &lt;span v-html=&quot;html&quot;&gt;&lt;/span&gt; span 的内容会被名为 &quot;html&quot; 的数据对象的内容所替换 可以在 Mustache 中使用表达式,但只能是单表达式 &lt;span&gt;{{ number +1 }}&lt;/span&gt; &lt;span&gt;{{ number == 1 ? 1 : 0 }}&lt;/span&gt; &lt;span&gt;{{ number.tofixed(2) }}&lt;/span&gt; 注意！！！ 不要在属性上使用 &quot;Mustache&quot; &lt;span v-bind:id={{ id }}&gt; 错误示例 &lt;/span&gt; ","link":"https://yuyang0564.github.io/5TNcrkqyR/"},{"title":"css 盒模型","content":"对一个网页来说，页面上所有的元素对象，实际呈现的形式都是一个盒子形状的抽象模型 盒模型由margin , padding , border , content 组成 ,元素真实的大小不包含margin W3C标准盒模型: 盒子占据页面的尺寸为 margin + padding + border + content IE 盒模型: 盒子占据页面的尺寸为 margin + content 改变 css 盒模型 box-sizing 属性 值 content-box 在元素的宽度和高度之外绘制 padding 和 border border-box 元素的 padding 和 border 都在宽度和高度之内 div { width: 100px; height: 100px; border: 50px solid #ff0000; background-color: #d0d0d0d0; margin: 50px; } content-box border-box ","link":"https://yuyang0564.github.io/rimzBw6DU/"},{"title":"css 盒子阴影","content":"box-shadow 为元素的边框添加阴影效果 属性 值 h-shadow 水平阴影大小 (可以为负值) v-shadow 垂直阴影大小 (可以为负值) blur 模糊程度(值越小，模糊程度越低) spread 阴影范围的大小 color has / rgb div { box-shadow: 10px 10px 15px 5px #d0d0d0; } ","link":"https://yuyang0564.github.io/Z4fDbT_D-/"},{"title":"css border/outline","content":"border 设置元素的4个边框设置统一的样式 属性 值 width 像素单位 / 百分比 style solid(实线) / dotted(点状线) / dashed(虚线) / hidden/none(隐藏) color has / rgb / transparent 也可以针对某一边单独设置 例: div { border-top: 1px slid #ff0000; } outline 轮廓绘制在边框的外围 。它 不占据可视空间 可选值与 borde 一致 ","link":"https://yuyang0564.github.io/y8ek7idBn/"},{"title":"css 背景","content":"background-color 背景色 可选值 说明 color has \\ rgb transparent 透明 background-image 设置元素的背景图像 图像默认的范围一直到元素 padding 图像默认从左上角开始' 可选值 说明 url('URL') 图像的本地或网络地址 none 不显示背景图 background-position 设置背景图片的起始位置 可选值 值 说明 模糊位置 left / right / top / center / bottom 只设置一个时，另一个为 center 百分比 x% y% 只设置一个时，另一个为 50% 详细像素单位 xpx ypx 只设置一个时，另一个为 50% body { background-image: url('xx.png'); background-position: 50%; } backround-repeat 设置背景图片的平铺方式 可选值 说明 repeat 默认向水平和垂直方向上平铺 repeat-x 水平方向平铺 repeat-y 垂直方向平铺 no-repeat 不平铺 background-clip 背景图片的填充区域 IE11兼容 默认值： border-box 可选值 说明 border-box 背景图片从边框开始填充 padding-box 背景图片从 padding 开始填充 content-box 背景图片只在内容区填充 border-box padding-box content-box background-size 调整背景图片的大小 可选值 说明 像素单位 / 百分比 如果只设置一个值，另外一个为auto cover 等比例放大，最小时为图片大小 contain 等比例缩小, 最大时图片大小 background 简写 color 、 image 、 position / size 、 repeat body { background: #ff0000 url('xx.jpg') center/cover no-repeat; } ","link":"https://yuyang0564.github.io/oesfSfj13/"},{"title":"css 字体","content":"@font-face 设置 web 字体 属性 值 默认值 font-family 自定义字体名称 无(必须设置) src:url() 字体的url或本地字体文件 无(必须设置) font-style 设置字体显示的样式 normal font-weight 字体的粗细 normal 出于兼容性考虑，需要在 src:url(....) 之后使用 format 对字体设置明确的格式 src: url(...) format(...) format 可选值对照 名称 值 truetype .ttf woff .woff woff2 .woff2 embedded-opentype .eot svg .svg 定义字体 @font-face { font-familt: &quot;myFont&quot;; src: url(&quot;xx.eot&quot;); src: url(xx.ttf) format(&quot;truetype&quot;), url(xx.woff) format(&quot;woff&quot;), url(xx.woff2) format(&quot;woff2&quot;), url(xx.svg) fromat(&quot;svg&quot;); font-style: normal; font-weight: normal; } 引用字体 body { font-family: &quot;myFont&quot;; } font-family 引用字体,可同时设置多个字体作为回退，当浏览器没有找到相应的字体时，会依次向后读取 多个字体之间用 , 分隔 body { font-family: &quot;Times New Roman&quot; , serif , fantasy } ","link":"https://yuyang0564.github.io/xMEynXf8C/"},{"title":"css 常用文本属性","content":"color 设置文本的颜色 name hax rgb direction 设置文本的排列方向 ltr 从左向右排列 rtl 从右向左排列 .box { direction: rtl; } letter-spacing 设置文字之间的间距 允许使用负值 .box { letter-spacing: 15px; } white-space 文字是否换行 nowrap 不换行 .box { white-space: nowrap; } text-decoration 修饰文本 underline 为文本添加下划线 overline 为文本添加上划线 line-through 为文本添加删除线 .box { text-decoration: underline; text-decoration: overline; text-decoration: line-through; } text-indent 文本的首行缩进 length 通过像素单位，设置固定大小 % 基于父元素宽度的百分比 .box { text-indent: 32px; text-indent: 10%; } text-transform 文本的大小写 capitalize 每个单词以大写字母开头 uppercase 全部转为大写 lowecase 全部转为小写 text-align 设置行元素 , img 和 文本 的水平对齐方式 left 左对齐 right 右对齐 center 居中 justify 两端对齐 .box { text-align: left; text-align: right; text-align: center; text-align: justify; } vertical-align 行元素,img,文本 在水平方向与其他元素垂直方向的对齐方式 top 元素顶端与其他元素中最高的元素顶端对齐 bottom 元素顶端与其他元素中最低的元素顶端对齐 text-top 元素的顶端与父元素字体的顶端对齐 text-bottom 元素的底端与父元素字体的底端对齐 middle 元素放置在父元素的中间 .box { vertical-align: top; vertical-align: bottom; vertical-align: text-top; vertical-align: text-bottom; vertical-align: middle; } line-height 设置行间距(行高) 没有负值 number 设置为数值时，会与当前的字体尺寸相乘 length 像素单位 % 基于当前字体的百分比 text-overflow 当文本溢出包含的元素时的显示方式 clip 裁剪掉 ellipsis 以省略号代表被裁剪掉的文本 string 用自定义的字符串来代表被裁剪的文本 text-shadow 为文字添加阴影 h-shadow 水平阴影 v-shadow 垂直阴影 blur 模糊距离 color 颜色 ","link":"https://yuyang0564.github.io/3ZTbrXmjG/"},{"title":"uni-app AppId 的作用","content":"AppId 是Dcloud 应用的唯一标识 🔐 ， 主要用来区分各个应用 它在创建项目时，会自动生成。创建者即为项目的所有者 , 如果其他协作开发人员要使用该appid打包项目，则需要通过 开发者云端控制台 把协作人员加入到 协作者 使用 AppId 的场景 云打包控制权限 热更新 uni 推送 购买的原生插件 修改 AppId 可能引发的问题 丢失本地缓存数据 无法使用 wgt 热更新 云服务无法使用 购买的原生插件无法在新的appid上使用 ","link":"https://yuyang0564.github.io/KMjITJtJa/"},{"title":"规范1","content":"🚀 1. 单一变量模式 只使用一个变量声明在函数作用域的顶部，一次性声明并初始化即将用到的所有变量 ;(function(){ let a = 1, b = 2, c = 3 d = 4 })() 防止变量在定义前就被使用 提高可读性 🚀 2. for 循环时，缓存数组的长度 let length = arr.length for( let i = 0; i &lt; length; i++ ) { ... } 避免每次循环都去计算数组的长度 尤其在循环DOM时，平凡的查询DOM是非常耗时的 🚀 3. for-in 遍历 for-in 主要用来遍历对象，它的原意是&quot;枚举&quot; , 但是它也会遍历出原型上可枚举的属性。在大多数情况下这是没有必要的，通常通过 Object.hasOwnProperty 来过滤 非自有属性 for(let i in obj) { if(Object.prototype.hasOwnProperty.call(obj,i)) { // 只遍历自有属性 } } 🚀 4. parseInt 函数 parseInt 主要是从一个字符串中获取数值，它的第二个参数是一个进制参数 。 这个参数建议不能省略，应该始终都正确的设置，避免因为意外传递了一个不是进制的参数，导致返回 NaN parseInt(&quot;5&quot;,1) // NaN ","link":"https://yuyang0564.github.io/gui-fan/"},{"title":"uni-app wgt资源包升级","content":"1. 资源包升级时，需要提升版本 2. 在HBuildX 中生成wgt安装包，格式为 .wgt 结尾 [发行] -&gt; [制作应用 wgt 包] 3. 与服务端协商升级接口 4. 代码中通过环境判断APP端 // #ifdef APP-PLUS // #endif 5. 使用 uni.downloadFile 下载文件 const downloadTask = await uni.downloadFile({ url, success(res) { let {tempFilePath , statusCode} = res ... } }) 下载成功时会传入一个事件对象 参数 说明 tempFilePath 已下载文件的临时路径 statusCode 开发者服务返回的状态码 6. 监听下载( 可选 ) 上文中 uni.downloadFile 会返回一个 downloadTask 对象 downloadTask.onProgressUpdate(res=&gt;{ let { progress, // 下载进度百分比 totalBytesWritten, // 已经下载的数据长度, 单位 Bytes totalBytesExpectedToWrite // 数据总长度 , 单位 Bytes } = res }) downloadTask 对象可用方法 方法 说明 abort 中断当前下载 onProgressUpdate 监听下载进度变化 7. 通过 h5+ 的 install 方法来安装更新 步骤5 下载成功后会返回一个文件的临时路径 tempFilePath 安装成功后，需要重启才能生效 。通过 plus.runtime.restart() 方法 plus.runtime.install(tempFilePath , { force: false // 是否强制安装 },()=&gt;{ plus.runtime.restart() }()=&gt;{ // 安装失败回调 }) 注意事项: appid 识别应用的唯一 ID，不可变更 升级时需要通过条件编译识别APP平台 识别 manifest.json 中配置的版本号，需要在 plus.rumtime.getProperty 中获取 需要保持 HBuildX 的基座版本号与即将升级的APP 的基座版本号一致 安装完 wgt 必须重启应用才能生效 ","link":"https://yuyang0564.github.io/uni-app-wgt-zi-yuan-bao-sheng-ji/"},{"title":"uni-app  无法打开微信开发者工具","content":"刚接手的别人的项目，从svn一拉下来。从 hbuildx 运行到开发者工具时，一直卡在了 open IDE 就是打不开项目。。。😡😡 尝试一同，修改了一下 HBuildx 配置中的小程序 APPID，问题解决 同时也需要打开微信开发者工具中的 安全 -&gt; 开启服务端口 ","link":"https://yuyang0564.github.io/uni-app-wu-fa-da-kai-wei-xin-kai-fa-zhe-gong-ju/"},{"title":"uni-app 条件编译","content":"条件编译通过注释的写法，区分不同的环境 ✍️ 语法 #ifdef %PLATFORM% #endif 👓 %PLATFORM% 常用可选值 值 平台 APP-PLUS APP H5 H5 MP-WEIXIN 微信小程序 js // #ifdef APP-PLUS // #endif css /* #ifdef APP-PLUS */ /* #endif */ pages.json // #ifdef APP-PLUS // #endif template &lt;!-- #ifdef APP-PLUS--&gt; &lt;!-- #endif --&gt; ","link":"https://yuyang0564.github.io/uni-app-tiao-jian-bian-yi/"},{"title":"uni-app 差异化注意事项","content":"🌈 1. 不要把 js,css,scss 等文件直接放入 static 文件中，因为此文件是不会进行编译的 🌈 2. 在css中和组件中引入样式，只能通过相对路径的方式 @import url(&quot;../../xx.css&quot;); &lt;style&gt; @import &quot;../../xxx.css&quot; &lt;/style&gt; 🌈 3. 使用rpx 作为尺寸单位， 默认根据 750px 的宽度计算 🌈 4. 背景图片 不支持本地图片，可以转为base64 , 注意源文件不要大于 40Kb 🌈 5. 不支持 vue 的 classObject 的方式绑定样式 &lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt; &lt;script&gt; data: { classObject: { color: &quot;#fff&quot;, fontSize: &quot;16px&quot; } } &lt;/script&gt; 🌈 6. 不支持在自定义组件上使用 class 和 style 绑定 &lt;v-component :class=&quot;classStyle&quot; /&gt; 🌈 7. 事件修饰符只支持 .stop 阻止事件冒泡 ， 其他修饰符只在 H5 端有效 ","link":"https://yuyang0564.github.io/uni-app-chai-yi-hua-zhu-yi-shi-xiang/"}]}